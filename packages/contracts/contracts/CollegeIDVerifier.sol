// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "./CredentialRegistry.sol";

/**
 * @title CollegeIDVerifier
 * @dev On-chain ZK proof verification for College ID credentials
 */
contract CollegeIDVerifier {
    CredentialRegistry public registry;

    event ProofVerified(
        bytes32 indexed credentialId,
        address indexed verifier,
        bool isValid,
        uint256 timestamp
    );

    constructor(address _registry) {
        require(_registry != address(0), "Invalid registry address");
        registry = CredentialRegistry(_registry);
    }

    /**
     * @dev Verify College ID ZK proof on-chain
     * @param proof The ZK proof bytes
     * @param publicInputs Array of public inputs
     * @param credentialId The credential ID being verified
     * @param disclosedFieldsBitmap Bitmap of disclosed fields
     * @return isValid Whether the proof is valid
     */
    function verifyCollegeID(
        bytes calldata proof,
        uint256[] calldata publicInputs,
        bytes32 credentialId,
        uint256 disclosedFieldsBitmap
    ) external returns (bool isValid) {
        // 1. Check credential is not revoked
        require(registry.isCredentialValid(credentialId), "Credential is invalid or revoked");

        // 2. Verify the proof format
        require(proof.length > 0, "Invalid proof");
        require(publicInputs.length >= 5, "Invalid public inputs");

        // 3. Extract public inputs
        // publicInputs[0] = credentialId (as uint256)
        // publicInputs[1] = commitment
        // publicInputs[2] = disclosed fields bitmap
        // publicInputs[3] = issuer public key
        // publicInputs[4] = holder public key
        // Additional inputs for predicates...

        bytes32 inputCredentialId = bytes32(publicInputs[0]);
        require(inputCredentialId == credentialId, "Credential ID mismatch");

        // 4. Get credential from registry
        (
            address issuer,
            address holder,
            ,
            bytes32 commitment,
            ,
            ,
            bool revoked
        ) = registry.getCredential(credentialId);

        require(!revoked, "Credential revoked");

        // 5. Verify commitment matches
        bytes32 inputCommitment = bytes32(publicInputs[1]);
        require(inputCommitment == commitment, "Commitment mismatch");

        // 6. Verify disclosed fields bitmap matches
        require(publicInputs[2] == disclosedFieldsBitmap, "Bitmap mismatch");

        // 7. In production, call actual ZK verifier contract generated by Noir
        // This would use the Barretenberg verifier
        // For now, we do basic validation
        bool proofValid = _verifyProof(proof, publicInputs);
        
        require(proofValid, "Proof verification failed");

        // 8. Verify predicates if present
        if (publicInputs.length > 5) {
            _verifyPredicates(publicInputs);
        }

        emit ProofVerified(credentialId, msg.sender, true, block.timestamp);
        return true;
    }

    /**
     * @dev Internal proof verification (placeholder)
     * In production, this calls the Noir-generated verifier contract
     */
    function _verifyProof(bytes calldata proof, uint256[] calldata publicInputs) 
        internal 
        pure 
        returns (bool) 
    {
        // This is a simplified placeholder
        // Real implementation would call UltraPlonk verifier from Noir
        
        // Basic sanity checks
        if (proof.length == 0) return false;
        if (publicInputs.length == 0) return false;
        
        // In production: return UltraPlonkVerifier.verify(proof, publicInputs);
        return true; // Placeholder for development
    }

    /**
     * @dev Verify predicate results
     */
    function _verifyPredicates(uint256[] calldata publicInputs) internal pure {
        // publicInputs[5] = age_over_18 (0 or 1)
        // publicInputs[6] = year_valid (0 or 1)
        // publicInputs[7] = status_active (0 or 1)
        // publicInputs[8] = current_timestamp

        // Predicates are already verified in the ZK proof
        // We just ensure they're binary flags
        if (publicInputs.length > 5) {
            require(publicInputs[5] <= 1, "Invalid age predicate");
        }
        if (publicInputs.length > 6) {
            require(publicInputs[6] <= 1, "Invalid year predicate");
        }
        if (publicInputs.length > 7) {
            require(publicInputs[7] <= 1, "Invalid status predicate");
        }
    }

    /**
     * @dev Read-only verification (doesn't emit events)
     */
    function checkProofValidity(
        bytes calldata proof,
        uint256[] calldata publicInputs,
        bytes32 credentialId
    ) external view returns (bool) {
        if (!registry.isCredentialValid(credentialId)) return false;
        if (proof.length == 0) return false;
        if (publicInputs.length < 5) return false;

        bytes32 inputCredentialId = bytes32(publicInputs[0]);
        if (inputCredentialId != credentialId) return false;

        return true; // Simplified check
    }
}

